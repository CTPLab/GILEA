import pickle
from pathlib import Path

import numpy as np
import pyrallis
import torch
from dataclasses import dataclass

from configs.paths_config import model_paths
from models.stylegan3.model import SG3Generator


@dataclass
class Options:
    """ StyleGAN Args """
    # Path to StyleGAN model weights
    checkpoint_path: Path = Path(model_paths['stylegan3_ffhq_pt'])
    # Images resolution generated by the StyleGAN model
    stylegan_size: int = 1024
    # Is it the landscape model? If so, different init_kwargs are used to load the pretained StyleGAN model
    is_landscape: bool = False

    """ Global Direction Args """
    # Truncation used for generating the images
    truncation_psi: float = 0.5
    # Truncation cutoff used for generating the images
    truncation_cutoff: int = 8
    # Correct pose when generating images
    pseudo_align: bool = True

    """ General Args """
    # Path to directory in which result files are saved
    output_path: Path = Path("stats")
    # Number of samples used for computing the stats
    num_images: int = 100_000
    # Seed for random state
    random_state: int = 0


def save_stats(G, random_state, num_images, truncation_psi, truncation_cutoff, output_path):
    rnd = np.random.RandomState(random_state)
    z = rnd.randn(num_images, 512)
    z = torch.tensor(z).cuda()

    with torch.no_grad():
        ws = G.mapping(z=z, c=None, truncation_psi=truncation_psi, truncation_cutoff=truncation_cutoff)
        all_s = G.synthesis.W2S(ws)

    w = ws.cpu().numpy()[:, 0, :]
    result_w_path = output_path / 'W'
    np.save(result_w_path, w)

    all_s_np = {}
    all_s_1000 = {}
    s_mean = {}
    s_std = {}
    for layer in all_s.keys():
        s = all_s[layer].cpu().numpy()
        all_s_np[layer] = s
        all_s_1000[layer] = s[:1000]
        s_mean[layer] = s.mean(axis=0)
        s_std[layer] = s.std(axis=0)

    result_s_path = output_path / 'S'
    with open(result_s_path, "wb") as fp:
        pickle.dump(all_s_np, fp)

    result_s1000_path = output_path / 'S_1000'
    with open(result_s1000_path, "wb") as fp:
        pickle.dump(all_s_1000, fp)

    fourier_features_channels = all_s['input'].cpu().numpy()
    theta = np.arccos(fourier_features_channels[:, 0])

    theta_mean = np.mean(theta)
    x = fourier_features_channels[:, 2].mean()
    y = fourier_features_channels[:, 3].mean()

    transform = {}
    transform['theta'] = theta_mean
    transform['x'] = x
    transform['y'] = y

    s_stats = [transform, s_mean, s_std]

    result_s_stats_path = output_path / 's_stats'
    with open(result_s_stats_path, "wb") as fp:
        pickle.dump(s_stats, fp)


@pyrallis.wrap()
def main(args: Options):
    args.output_path.mkdir(exist_ok=True, parents=True)
    G = SG3Generator(args.checkpoint_path, res=args.stylegan_size,
                     config="landscape" if args.is_landscape else None).decoder
    save_stats(G, args.random_state, args.num_images, args.truncation_psi, args.truncation_cutoff, args.output_path)


if __name__ == "__main__":
    main()
